package pro.civitaspo.digdag.plugin.ecs_task.run

import com.amazonaws.services.ecs.model.{
  AwsVpcConfiguration,
  CapacityProviderStrategyItem,
  ContainerOverride,
  Failure,
  KeyValuePair,
  NetworkConfiguration,
  PlacementConstraint,
  PlacementStrategy,
  RunTaskRequest,
  RunTaskResult,
  Tag,
  TaskOverride
}
import com.google.common.base.Optional
import com.google.common.collect.ImmutableList
import io.digdag.client.config.{Config, ConfigKey}
import io.digdag.spi.{ImmutableTaskResult, OperatorContext, TaskResult, TemplateEngine}
import io.digdag.util.DurationParam
import pro.civitaspo.digdag.plugin.ecs_task.AbstractEcsTaskOperator
import pro.civitaspo.digdag.plugin.ecs_task.exception.RetryTimeoutException

import scala.jdk.CollectionConverters._

class EcsTaskRunInternalOperator(operatorName: String, context: OperatorContext, systemConfig: Config, templateEngine: TemplateEngine)
    extends AbstractEcsTaskOperator(operatorName, context, systemConfig, templateEngine) {

  val capacityProviderStrategy: Seq[CapacityProviderStrategyItem] =
    params.parseListOrGetEmpty("capacity_provider_strategy", classOf[Config]).asScala.map(configureCapacityProviderStrategy).map(_.get).toSeq
  val cluster: String = params.get("cluster", classOf[String])
  val count: Optional[Int] = params.getOptional("count", classOf[Int])
  val group: Optional[String] = params.getOptional("group", classOf[String])
  val launchType: Optional[String] = params.getOptional("launch_type", classOf[String])
  val networkConfiguration: Optional[NetworkConfiguration] = configureNetworkConfiguration(params.parseNestedOrGetEmpty("network_configuration"))
  val overrides: Optional[TaskOverride] = configureTaskOverride(params.parseNestedOrGetEmpty("overrides"))

  val placementConstraints: Seq[PlacementConstraint] =
    params.parseListOrGetEmpty("placement_constraints", classOf[Config]).asScala.map(configurePlacementConstraint).map(_.get).toSeq

  val placementStrategy: Seq[PlacementStrategy] =
    params.parseListOrGetEmpty("placement_strategy", classOf[Config]).asScala.map(configurePlacementStrategy).map(_.get).toSeq
  val platformVersion: Optional[String] = params.getOptional("platform_version", classOf[String])
  val startedBy: Optional[String] = params.getOptional("started_by", classOf[String])

  val tags: Seq[Tag] =
    params.getMapOrEmpty("tags", classOf[String], classOf[String]).asScala.map((t: (String, String)) => new Tag().withKey(t._1).withValue(t._2)).toSeq
  val taskDefinition: String = params.get("task_definition", classOf[String]) // generated by ecs_task.register> operator if not set.

  val runRequestRetryInterval: DurationParam = params.get("run_request_retry_interval", classOf[DurationParam], DurationParam.parse("5s"))
  val runRequestRetryTimeout: DurationParam = params.get("run_request_retry_timeout", classOf[DurationParam], DurationParam.parse("5m"))

  protected def buildRunTaskRequest(): RunTaskRequest = {
    val req: RunTaskRequest = new RunTaskRequest()

    if (capacityProviderStrategy.nonEmpty) req.setCapacityProviderStrategy(capacityProviderStrategy.asJava)
    req.setCluster(cluster)
    if (count.isPresent) req.setCount(count.get)
    if (group.isPresent) req.setGroup(group.get)
    if (launchType.isPresent) req.setLaunchType(launchType.get)
    if (networkConfiguration.isPresent) req.setNetworkConfiguration(networkConfiguration.get)
    if (overrides.isPresent) req.setOverrides(overrides.get)
    if (placementConstraints.nonEmpty) req.setPlacementConstraints(placementConstraints.asJava)
    if (placementStrategy.nonEmpty) req.setPlacementStrategy(placementStrategy.asJava)
    if (platformVersion.isPresent) req.setPlatformVersion(platformVersion.get)
    if (startedBy.isPresent) req.setStartedBy(startedBy.get)
    if (tags.nonEmpty) req.setTags(tags.asJava)
    req.setTaskDefinition(taskDefinition)

    req
  }

  protected def configureCapacityProviderStrategy(c: Config): Optional[CapacityProviderStrategyItem] = {
    if (c.isEmpty) return Optional.absent()

    val base: Optional[Int] = c.getOptional("base", classOf[Int])
    val capacityProvider: Optional[String] = c.getOptional("capacity_provider", classOf[String])
    val weight: Optional[Int] = c.getOptional("weight", classOf[Int])

    val cps: CapacityProviderStrategyItem = new CapacityProviderStrategyItem()
    if (base.isPresent) cps.setBase(base.get)
    if (capacityProvider.isPresent) cps.setCapacityProvider(capacityProvider.get)
    if (weight.isPresent) cps.setWeight(weight.get)

    Optional.of(cps)
  }

  protected def configureNetworkConfiguration(c: Config): Optional[NetworkConfiguration] = {
    if (c.isEmpty) return Optional.absent()

    val awsvpcConfiguration: Optional[AwsVpcConfiguration] = configureAwsVpcConfiguration(c.parseNestedOrGetEmpty("awsvpc_configuration"))

    val nc: NetworkConfiguration = new NetworkConfiguration()
    if (awsvpcConfiguration.isPresent) nc.setAwsvpcConfiguration(awsvpcConfiguration.get)

    Optional.of(nc)
  }

  protected def configureAwsVpcConfiguration(c: Config): Optional[AwsVpcConfiguration] = {
    if (c.isEmpty) return Optional.absent()

    val assignPublicIp: Optional[String] = c.getOptional("assign_public_ip", classOf[String])
    val securityGroups: Seq[String] = c.parseListOrGetEmpty("security_groups", classOf[String]).asScala.toSeq
    val subnets: Seq[String] = c.parseListOrGetEmpty("subnets", classOf[String]).asScala.toSeq

    val avc: AwsVpcConfiguration = new AwsVpcConfiguration()
    if (assignPublicIp.isPresent) avc.setAssignPublicIp(assignPublicIp.get)
    if (securityGroups.nonEmpty) avc.setSecurityGroups(securityGroups.asJava)
    if (subnets.nonEmpty) avc.setSubnets(subnets.asJava)

    Optional.of(avc)
  }

  protected def configureTaskOverride(c: Config): Optional[TaskOverride] = {
    if (c.isEmpty) return Optional.absent()

    val containerOverrides: Seq[ContainerOverride] =
      c.parseListOrGetEmpty("container_overrides", classOf[Config]).asScala.map(configureContainerOverride).map(_.get).toSeq
    val executionRoleArn: Optional[String] = c.getOptional("execution_role_arn", classOf[String])
    val taskRoleArn: Optional[String] = c.getOptional("task_role_arn", classOf[String])

    val to: TaskOverride = new TaskOverride()
    if (containerOverrides.nonEmpty) to.setContainerOverrides(containerOverrides.asJava)
    if (executionRoleArn.isPresent) to.setExecutionRoleArn(executionRoleArn.get)
    if (taskRoleArn.isPresent) to.setTaskRoleArn(taskRoleArn.get)

    Optional.of(to)
  }

  protected def configureContainerOverride(c: Config): Optional[ContainerOverride] = {
    if (c.isEmpty) return Optional.absent()

    val command: Seq[String] = c.parseListOrGetEmpty("command", classOf[String]).asScala.toSeq
    val cpu: Optional[Int] = c.getOptional("cpu", classOf[Int])
    val environments: Seq[KeyValuePair] = c
      .getMapOrEmpty("environments", classOf[String], classOf[String])
      .asScala
      .map((t: (String, String)) => new KeyValuePair().withName(t._1).withValue(t._2))
      .toSeq // TODO: doc
    val memory: Optional[Int] = c.getOptional("memory", classOf[Int])
    val memoryReservation: Optional[Int] = c.getOptional("memory_reservation", classOf[Int])
    val name: Optional[String] = c.getOptional("name", classOf[String])

    val co: ContainerOverride = new ContainerOverride()
    if (command.nonEmpty) co.setCommand(command.asJava)
    if (cpu.isPresent) co.setCpu(cpu.get)
    if (environments.nonEmpty) co.setEnvironment(environments.asJava)
    if (memory.isPresent) co.setMemory(memory.get)
    if (memoryReservation.isPresent) co.setMemoryReservation(memoryReservation.get)
    if (name.isPresent) co.setName(name.get)

    Optional.of(co)
  }

  protected def configurePlacementConstraint(c: Config): Optional[PlacementConstraint] = {
    if (c.isEmpty) return Optional.absent()

    val expression: Optional[String] = c.getOptional("expression", classOf[String])
    val `type`: Optional[String] = c.getOptional("type", classOf[String])

    val pc: PlacementConstraint = new PlacementConstraint()
    if (expression.isPresent) pc.setExpression(expression.get)
    if (`type`.isPresent) pc.setType(`type`.get)

    Optional.of(pc)
  }

  protected def configurePlacementStrategy(c: Config): Optional[PlacementStrategy] = {
    if (c.isEmpty) return Optional.absent()

    val field: Optional[String] = c.getOptional("field", classOf[String])
    val `type`: Optional[String] = c.getOptional("type", classOf[String])

    val ps: PlacementStrategy = new PlacementStrategy()
    if (field.isPresent) ps.setField(field.get)
    if (`type`.isPresent) ps.setType(`type`.get)

    Optional.of(ps)
  }

  override def runTask(): TaskResult = {
    val req: RunTaskRequest = buildRunTaskRequest()
    logger.debug(req.toString)
    val result: RunTaskResult = requestTaskRun(req)
    logger.debug(result.toString)

    val paramsToStore = cf.create()
    val last_ecs_task_run: Config = paramsToStore.getNestedOrSetEmpty("last_ecs_task_run")
    last_ecs_task_run.set("task_arns", result.getTasks.asScala.map(_.getTaskArn).asJava)

    val builder: ImmutableTaskResult.Builder = TaskResult.defaultBuilder(cf)
    builder.resetStoreParams(ImmutableList.of(ConfigKey.of("last_ecs_task_run")))
    builder.storeParams(paramsToStore)
    builder.build()
  }

  protected def requestTaskRun(req: RunTaskRequest): RunTaskResult = {
    val startAtMillis: Long = System.currentTimeMillis()
    def timeSpentSec(): Long = (System.currentTimeMillis() - startAtMillis) / 1000

    def runUntilSuccess(numRetry: Int = 0): RunTaskResult = {
      val lastResult: RunTaskResult = aws.withEcs(_.runTask(req))
      val failures: Seq[Failure] = lastResult.getFailures.asScala.toSeq
      if (failures.isEmpty) return lastResult

      failures.foreach { f =>
        logger.warn(s"RunTask(${req.getTaskDefinition}, Retry: $numRetry, TimeSpent: ${timeSpentSec()}s) Failed -- Arn: ${f.getArn}, Reason: ${f.getReason}")
      }
      if (runRequestRetryTimeout.getDuration.minusSeconds(timeSpentSec()).isNegative)
        throw new RetryTimeoutException(
          s"RunTask(${req.getTaskDefinition}, Retry: $numRetry, TimeSpent: ${timeSpentSec()}s) Failed -- [${failures.map(_.toString).mkString(",")}]"
        )

      logger.info(s"Sleep $runRequestRetryInterval. (Retry: $numRetry, TimeSpent: ${timeSpentSec()}s)")
      Thread.sleep(runRequestRetryInterval.getDuration.toMillis)
      logger.info(s"Wake up. (Retry: $numRetry, TimeSpent: ${timeSpentSec()}s)")

      runUntilSuccess(numRetry = numRetry + 1)
    }
    runUntilSuccess()
  }
}
